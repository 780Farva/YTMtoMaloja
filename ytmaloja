#!/usr/bin/env bash
# This script was generated by bashly 1.2.10 (https://bashly.dev)
# Modifying it manually is not recommended

if [[ "${BASH_VERSINFO:-0}" -lt 4 ]]; then
  printf "bash version 4 or higher is required\n" >&2
  exit 1
fi

root_command() {
  log info "~*~*~*~ YTMtoMaloja ~*~*~*~"

  if [[ -n "${args[--timestamp]}" ]]; then
      export_time="${args[--timestamp]}"
  else
      export_time=$(date +%s)
  fi

  outfile="${args[out_dir]}/maloja_export${export_time}.json"

  log debug ${args[out_dir]}

  log info "I'll read from ${args[source]} and write my results to ${outfile}"

  process_data() {
    jq '[.[] | select(.header == "YouTube Music") |
  			select(has("subtitles")) |
  			.time |= (sub("\\.[[:digit:]]+"; "") | fromdateiso8601 ) |
  			. += { track: { "artists": [(.subtitles[].name | sub(" - Topic"; ""))]}} |
  			.track.title = (.title | sub("Watched "; ""))|
  			.track.album = null |
  			.track.length = null |
  			.duration = null |
        .origin = ("client:YTM") |

        del(.header, .subtitles, .title,  .activityControls, .titleUrl, .products)]'
  }

  processed_data=$(process_data < "${args[source]}")

  log debug "data preprocessing complete. ${processed_data}"

  echo $processed_data | \
  jq --arg export_time $export_time -aM \
  '{ "maloja": {"export_time": $export_time},

  "scrobbles": [.[]] }' > $outfile

  log info "~*~*~*~ fin ~*~*~*~"
}

version_command() {
  echo "$version"
}

ytmaloja_usage() {
  printf "ytmaloja - Convert Google Takeout dumps of YouTube Music listening history to Maloja's export format.\n\n"

  printf "%s\n" "Usage:"
  printf "  ytmaloja SOURCE [OUT_DIR] [OPTIONS]\n"
  printf "  ytmaloja --help | -h\n"
  printf "  ytmaloja --version | -v\n"
  echo

  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    printf "  %s\n" "--timestamp, -t EXPORT_TIME"
    printf "    unix timestamp to use as the export time in the maloja file. Also names the\n    output json.\n"
    echo

    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo
    printf "  %s\n" "--version, -v"
    printf "    Show version number\n"
    echo

    printf "%s\n" "Arguments:"

    printf "  %s\n" "SOURCE"
    printf "    Path to your watch-history.json file.\n"
    echo

    printf "  %s\n" "OUT_DIR"
    printf "    directory where the resulting maloja compatible file will be placed.\n"
    printf "    %s\n" "Default: ."
    echo

    printf "%s\n" "Examples:"
    printf "  ytmaloja ./watch-history.json results\n"
    printf "  DEBUG=1 ytmaloja ./watch-history.json\n"
    echo

  fi
}

normalize_input() {
  local arg passthru flags
  passthru=false

  while [[ $# -gt 0 ]]; do
    arg="$1"
    if [[ $passthru == true ]]; then
      input+=("$arg")
    elif [[ $arg =~ ^(--[a-zA-Z0-9_\-]+)=(.+)$ ]]; then
      input+=("${BASH_REMATCH[1]}")
      input+=("${BASH_REMATCH[2]}")
    elif [[ $arg =~ ^(-[a-zA-Z0-9])=(.+)$ ]]; then
      input+=("${BASH_REMATCH[1]}")
      input+=("${BASH_REMATCH[2]}")
    elif [[ $arg =~ ^-([a-zA-Z0-9][a-zA-Z0-9]+)$ ]]; then
      flags="${BASH_REMATCH[1]}"
      for ((i = 0; i < ${#flags}; i++)); do
        input+=("-${flags:i:1}")
      done
    elif [[ "$arg" == "--" ]]; then
      passthru=true
      input+=("$arg")
    else
      input+=("$arg")
    fi

    shift
  done
}

function _log_exception() {
  (
    BASHLOG_FILE=0;
    BASHLOG_JSON=0;
    BASHLOG_SYSLOG=0;

    log 'error' "Logging Exception: ${@}";
  );
}

function log() {
  local date_format="${BASHLOG_DATE_FORMAT:-+%F %T}";
  local date="$(date "${date_format}")";
  local date_s="$(date "+%s")";

  local file="${BASHLOG_FILE:-0}";
  local file_path="${BASHLOG_FILE_PATH:-/tmp/$(basename "${0}").log}";

  local json="${BASHLOG_JSON:-0}";
  local json_path="${BASHLOG_JSON_PATH:-/tmp/$(basename "${0}").log.json}";

  local syslog="${BASHLOG_SYSLOG:-0}";
  local tag="${BASHLOG_SYSLOG_TAG:-$(basename "${0}")}";
  local facility="${BASHLOG_SYSLOG_FACILITY:-local0}";
  local pid="${$}";

  local level="${1}";
  local upper="$(echo "${level}" | awk '{print toupper($0)}')";
  local debug_level="${DEBUG:-0}";

  shift 1;

  local line="${@}";

  # RFC 5424
  #
  # Numerical         Severity
  #   Code
  #
  #    0       Emergency: system is unusable
  #    1       Alert: action must be taken immediately
  #    2       Critical: critical conditions
  #    3       Error: error conditions
  #    4       Warning: warning conditions
  #    5       Notice: normal but significant condition
  #    6       Informational: informational messages
  #    7       Debug: debug-level messages

  local -A severities;
  severities['DEBUG']=7;
  severities['INFO']=6;
  severities['NOTICE']=5; # Unused
  severities['WARN']=4;
  severities['ERROR']=3;
  severities['CRIT']=2;   # Unused
  severities['ALERT']=1;  # Unused
  severities['EMERG']=0;  # Unused

  local severity="${severities[${upper}]:-3}"

  if [ "${debug_level}" -gt 0 ] || [ "${severity}" -lt 7 ]; then

    if [ "${syslog}" -eq 1 ]; then
      local syslog_line="${upper}: ${line}";

      logger \
        --id="${pid}" \
        -t "${tag}" \
        -p "${facility}.${severity}" \
        "${syslog_line}" \
        || _log_exception "logger --id=\"${pid}\" -t \"${tag}\" -p \"${facility}.${severity}\" \"${syslog_line}\"";
    fi;

    if [ "${file}" -eq 1 ]; then
      local file_line="${date} [${upper}] ${line}";
      echo -e "${file_line}" >> "${file_path}" \
        || _log_exception "echo -e \"${file_line}\" >> \"${file_path}\"";
    fi;

    if [ "${json}" -eq 1 ]; then
      local json_line="$(printf '{"timestamp":"%s","level":"%s","message":"%s"}' "${date_s}" "${level}" "${line}")";
      echo -e "${json_line}" >> "${json_path}" \
        || _log_exception "echo -e \"${json_line}\" >> \"${json_path}\"";
    fi;

  fi;

  local -A colours;
  colours['DEBUG']='\033[34m'  # Blue
  colours['INFO']='\033[32m'   # Green
  colours['NOTICE']=''         # Unused
  colours['WARN']='\033[33m'   # Yellow
  colours['ERROR']='\033[31m'  # Red
  colours['CRIT']=''           # Unused
  colours['ALERT']=''          # Unused
  colours['EMERG']=''          # Unused
  colours['DEFAULT']='\033[0m' # Default

  local norm="${colours['DEFAULT']}";
  local colour="${colours[${upper}]:-\033[31m}";

  local std_line="${colour}${date} [${upper}] ${line}${norm}";

  # Standard Output (Pretty)
  case "${level}" in
    'info'|'warn')
      echo -e "${std_line}";
      ;;
    'debug')
      if [ "${debug_level}" -gt 0 ]; then
        echo -e "${std_line}";
      fi;
      ;;
    'error')
      echo -e "${std_line}" >&2;
      if [ "${debug_level}" -gt 0 ]; then
        echo -e "Here's a shell to debug with. 'exit 0' to continue. Other exit codes will abort - parent shell will terminate.";
        bash || exit "${?}";
      fi;
      ;;
    *)
      log 'error' "Undefined log level trying to log: ${@}";
      ;;
  esac
}

declare prev_cmd="null";
declare this_cmd="null";
trap 'prev_cmd=$this_cmd; this_cmd=$BASH_COMMAND' DEBUG \
  && log debug 'DEBUG trap set' \
  || log error 'DEBUG trap failed to set';

validate_file_exists() {
  [[ -f "$1" ]] || echo "must be an existing file"
}

validate_parent_dir_exists() {
  [[ -d "$(dirname $1)" ]] || echo "Parent directory of $1 does not exist."
}

validate_timestamp() {
    local input="$1"

    # Check if the input is an integer using regex
    if ! [[ $input =~ ^[0-9]+$ ]]; then
        echo "must be a valid unix timestamp"
        return
    fi

    # Check if the integer falls within a reasonable range for Unix timestamps
    local min_timestamp=0
    local max_timestamp=$(date -d '2106-02-07' +%s)  # Maximum representable Unix time as of now

    if (( input < min_timestamp || input > max_timestamp )); then
        echo "must be a valid unix timestamp"

    fi
}

parse_requirements() {

  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --version | -v)
        version_command
        exit
        ;;

      --help | -h)
        long_usage=yes
        ytmaloja_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  action="root"

  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      --timestamp | -t)

        if [[ -n ${2+x} ]]; then
          args['--timestamp']="$2"
          shift
          shift
        else
          printf "%s\n" "--timestamp requires an argument: --timestamp, -t EXPORT_TIME" >&2
          exit 1
        fi
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)

        if [[ -z ${args['source']+x} ]]; then
          args['source']=$1
          shift

        elif [[ -z ${args['out_dir']+x} ]]; then
          args['out_dir']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  if [[ -z ${args['source']+x} ]]; then
    printf "missing required argument: SOURCE\nusage: ytmaloja SOURCE [OUT_DIR] [OPTIONS]\n" >&2

    exit 1
  fi

  [[ -n ${args['out_dir']:-} ]] || args['out_dir']="."

  if [[ -v args['source'] && -n $(validate_file_exists "${args['source']:-}") ]]; then
    printf "validation error in %s:\n%s\n" "SOURCE" "$(validate_file_exists "${args['source']:-}")" >&2
    exit 1
  fi

  if [[ -v args['out_dir'] && -n $(validate_parent_dir_exists "${args['out_dir']:-}") ]]; then
    printf "validation error in %s:\n%s\n" "OUT_DIR" "$(validate_parent_dir_exists "${args['out_dir']:-}")" >&2
    exit 1
  fi

  if [[ -v args['--timestamp'] && -n $(validate_timestamp "${args['--timestamp']:-}") ]]; then
    printf "validation error in %s:\n%s\n" "--timestamp, -t EXPORT_TIME" "$(validate_timestamp "${args['--timestamp']:-}")" >&2
    exit 1
  fi

}

initialize() {
  declare -g version="0.1.0"
  set -e

}

run() {

  declare -g long_usage=''
  declare -g -A args=()
  declare -g -A deps=()
  declare -g -a env_var_names=()
  declare -g -a input=()

  normalize_input "$@"
  parse_requirements "${input[@]}"

  case "$action" in
    "root") root_command ;;
  esac
}

initialize
run "$@"
